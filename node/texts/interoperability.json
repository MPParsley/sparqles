{
"ask[.]": "<p><b>SPARQL simple ASK query:</b></p><p>ASK {</p><p>?s ?o owl:Thing</p><p>} </p>",
"con[.]": "<p><b>SPARQL CONSTRUCT query with a single-triple pattern returning an RDF graph of resources and their types:</b></p><p>CONSTRUCT { ?x rdf:type ?o }</p><p>WHERE</p><p>{</p><p>&nbsp;&nbsp;?x rdf:type ?o .</p><p>} LIMIT 100</p>",
"con[join]": "<p><b>SPARQL CONSTRUCT query with two triple patterns and a join returning an RDF graph of resources and their types:</b></p><p>CONSTRUCT { ?x rdf:type ?v }</p><p>WHERE</p><p>{</p><p>&nbsp;&nbsp;?x rdf:type ?o .</p><p>&nbsp;&nbsp;?o rdf:type ?x</p><p>} LIMIT 100</p>",
"con[opt]": "<p><b>SPARQL CONSTRUCT query with two triple patterns and an optional returning an RDF graph of resources and their types:</b></p><p>CONSTRUCT { ?x rdf:type ?v }</p><p>WHERE</p><p>{</p><p>&nbsp;&nbsp;?x rdf:type ?o .</p><p>&nbsp;&nbsp;OPTIONAL {?o rdf:type ?v }</p><p>} LIMIT 100</p>",
"sel[.]*orderby*offset": "<p><b>SPARQL SELECT query with a single-triple pattern ordering results by the object variable using LIMIT and OFFSET typically used for paginating results:</b></p><p>SELECT ?v</p><p>WHERE { ?s rdf:type ?v }</p><p>ORDER BY ?v</p><p>LIMIT 100</p><p>OFFSET 101</p>",
"sel[.]*orderby-asc": "<p><b>SPARQL SELECT query with a single-triple pattern ordering results by the subject variable in an ascending way:</b></p><p>SELECT *</p><p>WHERE { ?s rdf:type ?o}</p><p>ORDER BY DESC(?s) LIMIT 100</p>",
"sel[.]*orderby-desc": "<p><b>SPARQL SELECT query with a single-triple pattern ordering results by the subject variable in a descending way:</b></p><p>SELECT *</p><p>WHERE { ?s rdf:type ?o}</p><p>ORDER BY DESC(?s) LIMIT 100</p>",
"sel[.]*orderby": "<p><b>SPARQL SELECT query with a single-triple pattern ordering results by the object variable:</b></p><p>SELECT ?v</p><p>WHERE { ?s rdf:type ?v }</p><p>ORDER BY ?v</p><p>LIMIT 100</p>",
"sel[.]": "<p><b>SPARQL SELECT query with a single-triple pattern: </b></p><p>SELECT * WHERE { ?s rdf:type ?o }  LIMIT 100</p>",
"sel[bnode]": "<p><b>SPARQL SELECT query with a single-triple pattern querying for a random blank node:</b></p><p>select distinct * where {?c rdf:type _:bn} LIMIT 100</p>",
"sel[empty]": "<p><b>SPARQL SELECT query with a single-triple pattern returning no results (using a non existing URI):</b></p><p>SELECT * WHERE { ?s rdf:type <http://nonsensical.com/1> }LIMIT 100</p>",
"sel[fil(!bound)]": "<p><b>SPARQL SELECT query with a single-triple pattern filtering only blank nodes:</b></p><p>SELECT  ?a ?c</p><p>WHERE</p><p>{ ?a rdf:type ?c . </p><p>&nbsp;&nbsp;OPTIONAL { ?c rdf:type ?e } . </p><p>&nbsp;&nbsp;FILTER (! bound(?e)) </p><p>} LIMIT 100</p>",
"sel[fil(blank)]": "<p><b>SPARQL SELECT query with a single-triple pattern filtering only blank nodes:</b></p><p>SELECT * WHERE { ?x rdf:type ?v . FILTER isBlank(?v) . } LIMIT 100</p>",
"sel[fil(bool)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a boolean in the object position:</b></p><p>SELECT * WHERE {</p><p>?s ?o false</p><p>} LIMIT 100</p>",
"sel[fil(iri)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filtering for variables being an IRI:</b></p><p>SELECT * WHERE { ?x rdf:type ?v . FILTER isIRI(?v) . } LIMIT 100</p>",
"sel[fil(num)]": "<p><b>SPARQL SELECT query with a single-triple pattern and an integer in the object position:</b></p><p>SELECT * WHERE {</p><p>?s ?o 12</p><p>} LIMIT 100</p>",
"sel[fil(regex)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filtering variables containing the \"thi\" string, case sensitive:</b></p><p>SELECT ?s ?val</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?val .</p><p>&nbsp;&nbsp;FILTER regex(?val, \"thi\")</p><p>} LIMIT 100</p>",
"sel[fil(regex)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filtering variables containing the \"thi\" string, case sensitive:</b></p><p>SELECT ?s ?val</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?val .</p><p>&nbsp;&nbsp;FILTER regex(?val, \"thi\")</p><p>} LIMIT 100</p>",
"sel[fil(regex-i)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filtering variables containing the \"thi\" string, ignoring case:</b></p><p>SELECT ?s ?val</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?val .</p><p>&nbsp;&nbsp;FILTER regex(?val, \"thi\", \"i\")</p><p>} LIMIT 100</p>",
"sel[fil(str)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filering for variables containing string values:</b></p><p>SELECT ?s WHERE {</p><p>&nbsp;&nbsp;  ?s rdf:type ?v .</p><p>&nbsp;&nbsp;  FILTER(datatype(xsd:string(?v)) = xsd:string) .</p><p>} LIMIT 100</p>",
"sel[from]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FROM NAMED clause:</b></p><p>SELECT * FROM <http://non.default.graph.com/graph1> </p><p>FROM NAMED <http://non.default.graph.com/graph2> { ?s ?p ?o } LIMIT 100</p>",
"sel[graph]": "<p><b>SPARQL SELECT query with a GRAPH operator and a single triple pattern:</b></p><p>SELECT * { </p><p>&nbsp;&nbsp;  GRAPH ?g { ?s rdf:type ?o }</p><p>} LIMIT 100</p>",
"sel[graph;join]": "<p><b>SPARQL SELECT query with a join of two triple patterns using GRAPH in one of the triple patterns:</b></p><p>SELECT * { </p><p>&nbsp;&nbsp;?s rdf:type ?o .</p><p>&nbsp;&nbsp;  GRAPH ?g { ?o ?p ?q }</p><p>} LIMIT 100</p>",
"sel[graph;union]": "<p><b>SPARQL SELECT query with a UNION of two triple patterns using GRAPH in one of the union sides:</b></p><p>SELECT * </p><p>{ </p><p>&nbsp;&nbsp; { ?s ?p ?o }</p><p>&nbsp;&nbsp;UNION</p><p>&nbsp;&nbsp; { GRAPH ?g { ?s ?p ?o } }</p><p>} LIMIT 100</p>",
"sel[join]": "<p><b>SPARQL SELECT query with two triple patterns and a join:</b> SELECT * WHERE { ?s rdf:type ?o . ?o ?p ?o2 } LIMIT 100</p>",
"sel[opt]": "<p><b>SPARQL SELECT query with two triple patterns and an optional:</b> SELECT * WHERE { ?s rdf:type ?o OPTIONAL {?o ?p ?x}} LIMIT 100</p>",
"sel[union]": "<p><b>SPARQL SELECT query with a UNION of two triple patterns:</b> SELECT * WHERE { {?s rdf:type ?o} UNION {?o rdf:type ?x}} LIMIT 100</p>",
"sel-distinct[.]": "<p><b>SPARQL SELECT query with a single-triple pattern using DISTINCT:</b> SELECT DISTINCT * WHERE { ?s rdf:type ?o } LIMIT 100</p>",
"sel-reduced[.]": "<p><b>SPARQL SELECT query with a UNION of two triple patterns using REDUCED:</b></p><p>SELECT REDUCED * </p><p>WHERE { </p><p>&nbsp;&nbsp;{ ?s rdf:type ?o } UNION { ?s rdf:type owl:Thing }</p><p>} LIMIT 100</p>",
"ask[fil(!in)]": "<p>ASK {</p><p>&nbsp;&nbsp;FILTER(2 NOT IN ())</p><p>}</p>",
"sel[avg]*groupby": "<p>PREFIX : <http://www.example.org/></p><p>PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#></p><p>SELECT ?s (AVG(?o) AS ?avg)</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?o</p><p>} </p><p>GROUP BY ?s</p><p>HAVING (AVG(?o) <= 2.0)</p><p>LIMIT 100</p>",
"sel[bind]": "<p>SELECT ?z</p><p>{</p><p>  ?s rdf:type ?o .</p><p>  BIND(?o+10 AS ?z)</p><p>} LIMIT 100</p>",
"sel[fil(!exists)]": "<p>SELECT *</p><p>WHERE</p><p>{&nbsp;&nbsp;?p rdf:type ?type .</p><p>&nbsp;&nbsp;FILTER NOT EXISTS {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;?p owl:sameAs ?same</p><p>&nbsp;&nbsp;}</p><p>} LIMIT 100</p>",
"sel[fil(contains)]": "<p>SELECT ?s ?str WHERE {</p><p>&nbsp;&nbsp;?s ?p ?str</p><p>&nbsp;&nbsp;FILTER CONTAINS(?str, \"a\")</p><p>} LIMIT 100</p>",
"sel[fil(exists)]": "<p>SELECT *</p><p>WHERE</p><p>{&nbsp;&nbsp;?p rdf:type ?type .</p><p>&nbsp;&nbsp;FILTER EXISTS {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;?p owl:sameAs ?same</p><p>&nbsp;&nbsp;}</p><p>} LIMIT 100</p>",
"sel[fil(start)]": "<p>SELECT ?s ?str WHERE {</p><p>&nbsp;&nbsp;?s ?p ?str</p><p>&nbsp;&nbsp;FILTER STRSTARTS(STR(?str), \"1\")</p><p>}</p>",
"sel[max]": "<p>SELECT (MAX(?o) AS ?max)</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?o</p><p>} LIMIT 100</p>",
"sel[min]": "<p>SELECT ?s (MIN(?o) AS ?min)</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?o</p><p>} </p><p>GROUP BY ?s</p><p>LIMIT 100</p>",
"sel[minus]": "<p>SELECT *</p><p>WHERE</p><p>{&nbsp;&nbsp;?p rdf:type ?type .</p><p>&nbsp;&nbsp;MINUS {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;?p owl:sameAs ?same</p><p>&nbsp;&nbsp;}</p><p>} LIMIT 100</p><p>select  ?x ?p where {</p><p>graph ?g {</p><p>{select * where {?x rdf:type ?y}}</p><p>}</p><p>} LIMIT 100</p>",
"sel[subq;graph]": "<p>select  ?x ?p where {</p><p>graph ?g {</p><p>{select * where {?x rdf:type ?y}}</p><p>}</p><p>} LIMIT 100</p>",
"sel[sum]": "<p>SELECT ?s (SUM(?o) AS ?sum)</p><p>WHERE {</p><p>&nbsp;&nbsp;?s ?p ?o</p><p>} </p><p>GROUP BY ?s</p><p>LIMIT 100</p>",
"sel[values]": "<p>SELECT ?p</p><p>{</p><p>   ?p rdf:type ?o </p><p>} </p><p>VALUES ?o { owl:Thing }</p>"
}